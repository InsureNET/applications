{
  "contractName": "OraclizeI",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.5.16+commit.9c3226ce\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/Users/jaxcoder/Documents/Blockchain/InsureNET/applications/admin-tool/src/contracts/vendors/usingOraclize.sol\":\"OraclizeI\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"/Users/jaxcoder/Documents/Blockchain/InsureNET/applications/admin-tool/src/contracts/vendors/usingOraclize.sol\":{\"keccak256\":\"0x61076fe898950c7bfdc68aee1fe97b0a7f7a12256f21b39549f1ce2cef480f9e\",\"urls\":[\"bzz-raw://9d304063fe310d18c41e027105485afb2b0b87f0e3a1d117c02775663bd93575\",\"dweb:/ipfs/QmWhcPUBY1yptMKrFY8tkjcFTTqDrgQcKqUxNcWK2Znsvr\"]}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50603e80601d6000396000f3fe6080604052600080fdfea265627a7a723158209bea931dc9793a5c0d19768ef4e951916865b3600159c3d5ed8cf0905549ec6964736f6c63430005100032",
  "deployedBytecode": "0x6080604052600080fdfea265627a7a723158209bea931dc9793a5c0d19768ef4e951916865b3600159c3d5ed8cf0905549ec6964736f6c63430005100032",
  "sourceMap": "1577:54967:27:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1577:54967:27;;;;;;;",
  "deployedSourceMap": "1577:54967:27:-;;;;;",
  "source": "// // <ORACLIZE_API>\n// // Release targetted at solc 0.4.25 to silence compiler warning/error messages, compatible down to 0.4.22\n// /*\n// Copyright (c) 2015-2016 Oraclize SRL\n// Copyright (c) 2016 Oraclize LTD\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// */\n\n// // This api is currently targeted at 0.4.22 to 0.4.25 (stable builds), please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\n\npragma solidity 0.5.16;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\n\ncontract OraclizeI {\n//     address public cbAddress;\n\n//     function query (\n//         uint _timestamp,\n//         string memory _datasource,\n//         string memory _arg\n//     ) public payable returns (bytes32 _id);\n\n//     function query_withGasLimit (\n//         uint _timestamp,\n//         string memory _datasource,\n//         string memory _arg,\n//         uint _gaslimit\n//     ) public payable returns (bytes32 _id);\n\n//     function query2 (\n//         uint _timestamp,\n//         string memory _datasource,\n//         string memory _arg1,\n//         string memory _arg2\n//     ) public payable returns (bytes32 _id);\n\n//     function query2_withGasLimit (\n//         uint _timestamp,\n//         string memory _datasource,\n//         string memory _arg1,\n//         string memory _arg2,\n//         uint _gaslimit\n//     ) public payable returns (bytes32 _id);\n\n//     function queryN (\n//         uint _timestamp,\n//         string memory _datasource,\n//         bytes memory _argN\n//     ) public payable returns (bytes32 _id);\n\n//     function queryN_withGasLimit (\n//         uint _timestamp,\n//         string memory _datasource,\n//         bytes memory _argN,\n//         uint _gaslimit\n//     ) public payable returns (bytes32 _id);\n\n//     function getPrice (\n//         string memory _datasource\n//     ) public returns (uint _dsprice);\n\n//     function getPrice (\n//         string memory _datasource,\n//         uint gaslimit\n//     ) public returns (uint _dsprice);\n\n//     function setProofType (\n//         byte _proofType\n//     ) public;\n\n//     function setCustomGasPrice (\n//         uint _gasPrice\n//     ) public;\n\n//     function randomDS_getSessionPubKeyHash (\n\n//     ) public view returns(bytes32);\n// }\n\n// contract OraclizeAddrResolverI {\n//     function getAddress() public returns (address _addr);\n// }\n\n// /*\n// Begin solidity-cborutils\n// https://github.com/smartcontractkit/solidity-cborutils\n// MIT License\n// Copyright (c) 2018 SmartContract ChainLink, Ltd.\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//  */\n\n// library Buffer {\n//     struct buffer {\n//         bytes buf;\n//         uint capacity;\n//     }\n\n//     function init(buffer memory buf, uint _capacity) internal pure {\n//         uint capacity = _capacity;\n//         if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n//         // Allocate space for the buffer data\n//         buf.capacity = capacity;\n//         assembly {\n//             let ptr := mload(0x40)\n//             mstore(buf, ptr)\n//             mstore(ptr, 0)\n//             mstore(0x40, add(ptr, capacity))\n//         }\n//     }\n\n//     function resize(buffer memory buf, uint capacity) private pure {\n//         bytes memory oldbuf = buf.buf;\n//         init(buf, capacity);\n//         append(buf, oldbuf);\n//     }\n\n//     function max(uint a, uint b) private pure returns(uint) {\n//         if(a > b) {\n//             return a;\n//         }\n//         return b;\n//     }\n\n//     /**\n//      * @dev Appends a byte array to the end of the buffer. Resizes if doing so\n//      *      would exceed the capacity of the buffer.\n//      * @param buf The buffer to append to.\n//      * @param data The data to append.\n//      * @return The original buffer.\n//      */\n//     function append(buffer memory buf, bytes memory data) internal pure returns(buffer memory) {\n//         if(data.length + buf.buf.length > buf.capacity) {\n//             resize(buf, max(buf.capacity, data.length) * 2);\n//         }\n\n//         uint dest;\n//         uint src;\n//         uint len = data.length;\n//         assembly {\n//             // Memory address of the buffer data\n//             let bufptr := mload(buf)\n//             // Length of existing buffer data\n//             let buflen := mload(bufptr)\n//             // Start address = buffer address + buffer length + sizeof(buffer length)\n//             dest := add(add(bufptr, buflen), 32)\n//             // Update buffer length\n//             mstore(bufptr, add(buflen, mload(data)))\n//             src := add(data, 32)\n//         }\n\n//         // Copy word-length chunks while possible\n//         for(; len >= 32; len -= 32) {\n//             assembly {\n//                 mstore(dest, mload(src))\n//             }\n//             dest += 32;\n//             src += 32;\n//         }\n\n//         // Copy remaining bytes\n//         uint mask = 256 ** (32 - len) - 1;\n//         assembly {\n//             let srcpart := and(mload(src), not(mask))\n//             let destpart := and(mload(dest), mask)\n//             mstore(dest, or(destpart, srcpart))\n//         }\n\n//         return buf;\n//     }\n\n//     /**\n//      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n//      * exceed the capacity of the buffer.\n//      * @param buf The buffer to append to.\n//      * @param data The data to append.\n//      * @return The original buffer.\n//      */\n//     function append(buffer memory buf, uint8 data) internal pure {\n//         if(buf.buf.length + 1 > buf.capacity) {\n//             resize(buf, buf.capacity * 2);\n//         }\n\n//         assembly {\n//             // Memory address of the buffer data\n//             let bufptr := mload(buf)\n//             // Length of existing buffer data\n//             let buflen := mload(bufptr)\n//             // Address = buffer address + buffer length + sizeof(buffer length)\n//             let dest := add(add(bufptr, buflen), 32)\n//             mstore8(dest, data)\n//             // Update buffer length\n//             mstore(bufptr, add(buflen, 1))\n//         }\n//     }\n\n//     /**\n//      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n//      * exceed the capacity of the buffer.\n//      * @param buf The buffer to append to.\n//      * @param data The data to append.\n//      * @return The original buffer.\n//      */\n//     function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n//         if(len + buf.buf.length > buf.capacity) {\n//             resize(buf, max(buf.capacity, len) * 2);\n//         }\n\n//         uint mask = 256 ** len - 1;\n//         assembly {\n//             // Memory address of the buffer data\n//             let bufptr := mload(buf)\n//             // Length of existing buffer data\n//             let buflen := mload(bufptr)\n//             // Address = buffer address + buffer length + sizeof(buffer length) + len\n//             let dest := add(add(bufptr, buflen), len)\n//             mstore(dest, or(and(mload(dest), not(mask)), data))\n//             // Update buffer length\n//             mstore(bufptr, add(buflen, len))\n//         }\n//         return buf;\n//     }\n// }\n\n// library CBOR {\n//     using Buffer for Buffer.buffer;\n\n//     uint8 private constant MAJOR_TYPE_INT = 0;\n//     uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n//     uint8 private constant MAJOR_TYPE_BYTES = 2;\n//     uint8 private constant MAJOR_TYPE_STRING = 3;\n//     uint8 private constant MAJOR_TYPE_ARRAY = 4;\n//     uint8 private constant MAJOR_TYPE_MAP = 5;\n//     uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n//     function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n//         if(value <= 23) {\n//             buf.append(uint8((major << 5) | value));\n//         } else if(value <= 0xFF) {\n//             buf.append(uint8((major << 5) | 24));\n//             buf.appendInt(value, 1);\n//         } else if(value <= 0xFFFF) {\n//             buf.append(uint8((major << 5) | 25));\n//             buf.appendInt(value, 2);\n//         } else if(value <= 0xFFFFFFFF) {\n//             buf.append(uint8((major << 5) | 26));\n//             buf.appendInt(value, 4);\n//         } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n//             buf.append(uint8((major << 5) | 27));\n//             buf.appendInt(value, 8);\n//         }\n//     }\n\n//     function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n//         buf.append(uint8((major << 5) | 31));\n//     }\n\n//     function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n//         encodeType(buf, MAJOR_TYPE_INT, value);\n//     }\n\n//     function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n//         if(value >= 0) {\n//             encodeType(buf, MAJOR_TYPE_INT, uint(value));\n//         } else {\n//             encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n//         }\n//     }\n\n//     function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\n//         encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n//         buf.append(value);\n//     }\n\n//     function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\n//         encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n//         buf.append(bytes(value));\n//     }\n\n//     function startArray(Buffer.buffer memory buf) internal pure {\n//         encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n//     }\n\n//     function startMap(Buffer.buffer memory buf) internal pure {\n//         encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n//     }\n\n//     function endSequence(Buffer.buffer memory buf) internal pure {\n//         encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n//     }\n// }\n\n// /*\n// End solidity-cborutils\n//  */\n\n// contract usingOraclize {\n//     uint constant day = 60*60*24;\n//     uint constant week = 60*60*24*7;\n//     uint constant month = 60*60*24*30;\n//     byte constant proofType_NONE = 0x00;\n//     byte constant proofType_TLSNotary = 0x10;\n//     byte constant proofType_Ledger = 0x30;\n//     byte constant proofType_Android = 0x40;\n//     byte constant proofType_Native = 0xF0;\n//     byte constant proofStorage_IPFS = 0x01;\n//     uint8 constant networkID_auto = 0;\n//     uint8 constant networkID_mainnet = 1;\n//     uint8 constant networkID_testnet = 2;\n//     uint8 constant networkID_morden = 2;\n//     uint8 constant networkID_consensys = 161;\n\n//     OraclizeAddrResolverI OAR;\n\n//     OraclizeI oraclize;\n//     modifier oraclizeAPI {\n//         if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n//             oraclize_setNetwork(networkID_auto);\n\n//         if(address(oraclize) != OAR.getAddress())\n//             oraclize = OraclizeI(OAR.getAddress());\n\n//         _;\n//     }\n//     modifier coupon(string code){\n//         oraclize = OraclizeI(OAR.getAddress());\n//         _;\n//     }\n\n//     function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n//       return oraclize_setNetwork();\n//       networkID; // silence the warning and remain backwards compatible\n//     }\n//     function oraclize_setNetwork() internal returns(bool){\n//         if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n//             OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n//             oraclize_setNetworkName(\"eth_mainnet\");\n//             return true;\n//         }\n//         if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n//             OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n//             oraclize_setNetworkName(\"eth_ropsten3\");\n//             return true;\n//         }\n//         if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n//             OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n//             oraclize_setNetworkName(\"eth_kovan\");\n//             return true;\n//         }\n//         if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n//             OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n//             oraclize_setNetworkName(\"eth_rinkeby\");\n//             return true;\n//         }\n//         if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n//             OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n//             return true;\n//         }\n//         if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n//             OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n//             return true;\n//         }\n//         if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n//             OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n//             return true;\n//         }\n//         return false;\n//     }\n\n//     function __callback(bytes32 myid, string result) public {\n//         __callback(myid, result, new bytes(0));\n//     }\n//     function __callback(bytes32 myid, string result, bytes proof) public {\n//       return;\n//       // Following should never be reached with a preceding return, however\n//       // this is just a placeholder function, ideally meant to be defined in\n//       // child contract when proofs are used\n//       myid; result; proof; // Silence compiler warnings\n//       oraclize = OraclizeI(0); // Additional compiler silence about making function pure/view.\n//     }\n\n//     function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n//         return oraclize.getPrice(datasource);\n//     }\n\n//     function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n//         return oraclize.getPrice(datasource, gaslimit);\n//     }\n\n//     function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         return oraclize.query.value(price)(0, datasource, arg);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         return oraclize.query.value(price)(timestamp, datasource, arg);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         bytes memory args = stra2cbor(argN);\n//         return oraclize.queryN.value(price)(0, datasource, args);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         bytes memory args = stra2cbor(argN);\n//         return oraclize.queryN.value(price)(timestamp, datasource, args);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         bytes memory args = stra2cbor(argN);\n//         return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         bytes memory args = stra2cbor(argN);\n//         return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n\n//     function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n\n//     function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         string[] memory dynargs = new string[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         bytes memory args = ba2cbor(argN);\n//         return oraclize.queryN.value(price)(0, datasource, args);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource);\n//         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n//         bytes memory args = ba2cbor(argN);\n//         return oraclize.queryN.value(price)(timestamp, datasource, args);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         bytes memory args = ba2cbor(argN);\n//         return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n//         uint price = oraclize.getPrice(datasource, gaslimit);\n//         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n//         bytes memory args = ba2cbor(argN);\n//         return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](1);\n//         dynargs[0] = args[0];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n\n//     function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](2);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](3);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n\n//     function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](4);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(timestamp, datasource, dynargs);\n//     }\n//     function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n//     }\n//     function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n//         bytes[] memory dynargs = new bytes[](5);\n//         dynargs[0] = args[0];\n//         dynargs[1] = args[1];\n//         dynargs[2] = args[2];\n//         dynargs[3] = args[3];\n//         dynargs[4] = args[4];\n//         return oraclize_query(datasource, dynargs, gaslimit);\n//     }\n\n//     function oraclize_cbAddress() oraclizeAPI internal returns (address){\n//         return oraclize.cbAddress();\n//     }\n//     function oraclize_setProof(byte proofP) oraclizeAPI internal {\n//         return oraclize.setProofType(proofP);\n//     }\n//     function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n//         return oraclize.setCustomGasPrice(gasPrice);\n//     }\n\n//     function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n//         return oraclize.randomDS_getSessionPubKeyHash();\n//     }\n\n//     function getCodeSize(address _addr) view internal returns(uint _size) {\n//         assembly {\n//             _size := extcodesize(_addr)\n//         }\n//     }\n\n//     function parseAddr(string _a) internal pure returns (address){\n//         bytes memory tmp = bytes(_a);\n//         uint160 iaddr = 0;\n//         uint160 b1;\n//         uint160 b2;\n//         for (uint i=2; i<2+2*20; i+=2){\n//             iaddr *= 256;\n//             b1 = uint160(tmp[i]);\n//             b2 = uint160(tmp[i+1]);\n//             if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n//             else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n//             else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n//             if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n//             else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n//             else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n//             iaddr += (b1*16+b2);\n//         }\n//         return address(iaddr);\n//     }\n\n//     function strCompare(string _a, string _b) internal pure returns (int) {\n//         bytes memory a = bytes(_a);\n//         bytes memory b = bytes(_b);\n//         uint minLength = a.length;\n//         if (b.length < minLength) minLength = b.length;\n//         for (uint i = 0; i < minLength; i ++)\n//             if (a[i] < b[i])\n//                 return -1;\n//             else if (a[i] > b[i])\n//                 return 1;\n//         if (a.length < b.length)\n//             return -1;\n//         else if (a.length > b.length)\n//             return 1;\n//         else\n//             return 0;\n//     }\n\n//     function indexOf(string _haystack, string _needle) internal pure returns (int) {\n//         bytes memory h = bytes(_haystack);\n//         bytes memory n = bytes(_needle);\n//         if(h.length < 1 || n.length < 1 || (n.length > h.length))\n//             return -1;\n//         else if(h.length > (2**128 -1))\n//             return -1;\n//         else\n//         {\n//             uint subindex = 0;\n//             for (uint i = 0; i < h.length; i ++)\n//             {\n//                 if (h[i] == n[0])\n//                 {\n//                     subindex = 1;\n//                     while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n//                     {\n//                         subindex++;\n//                     }\n//                     if(subindex == n.length)\n//                         return int(i);\n//                 }\n//             }\n//             return -1;\n//         }\n//     }\n\n//     function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n//         bytes memory _ba = bytes(_a);\n//         bytes memory _bb = bytes(_b);\n//         bytes memory _bc = bytes(_c);\n//         bytes memory _bd = bytes(_d);\n//         bytes memory _be = bytes(_e);\n//         string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n//         bytes memory babcde = bytes(abcde);\n//         uint k = 0;\n//         for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n//         for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n//         for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n//         for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n//         for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n//         return string(babcde);\n//     }\n\n//     function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n//         return strConcat(_a, _b, _c, _d, \"\");\n//     }\n\n//     function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n//         return strConcat(_a, _b, _c, \"\", \"\");\n//     }\n\n//     function strConcat(string _a, string _b) internal pure returns (string) {\n//         return strConcat(_a, _b, \"\", \"\", \"\");\n//     }\n\n//     // parseInt\n//     function parseInt(string _a) internal pure returns (uint) {\n//         return parseInt(_a, 0);\n//     }\n\n//     // parseInt(parseFloat*10^_b)\n//     function parseInt(string _a, uint _b) internal pure returns (uint) {\n//         bytes memory bresult = bytes(_a);\n//         uint mint = 0;\n//         bool decimals = false;\n//         for (uint i=0; i<bresult.length; i++){\n//             if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n//                 if (decimals){\n//                    if (_b == 0) break;\n//                     else _b--;\n//                 }\n//                 mint *= 10;\n//                 mint += uint(bresult[i]) - 48;\n//             } else if (bresult[i] == 46) decimals = true;\n//         }\n//         if (_b > 0) mint *= 10**_b;\n//         return mint;\n//     }\n\n//     function uint2str(uint i) internal pure returns (string){\n//         if (i == 0) return \"0\";\n//         uint j = i;\n//         uint len;\n//         while (j != 0){\n//             len++;\n//             j /= 10;\n//         }\n//         bytes memory bstr = new bytes(len);\n//         uint k = len - 1;\n//         while (i != 0){\n//             bstr[k--] = byte(48 + i % 10);\n//             i /= 10;\n//         }\n//         return string(bstr);\n//     }\n\n//     using CBOR for Buffer.buffer;\n//     function stra2cbor(string[] arr) internal pure returns (bytes) {\n//         safeMemoryCleaner();\n//         Buffer.buffer memory buf;\n//         Buffer.init(buf, 1024);\n//         buf.startArray();\n//         for (uint i = 0; i < arr.length; i++) {\n//             buf.encodeString(arr[i]);\n//         }\n//         buf.endSequence();\n//         return buf.buf;\n//     }\n\n//     function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n//         safeMemoryCleaner();\n//         Buffer.buffer memory buf;\n//         Buffer.init(buf, 1024);\n//         buf.startArray();\n//         for (uint i = 0; i < arr.length; i++) {\n//             buf.encodeBytes(arr[i]);\n//         }\n//         buf.endSequence();\n//         return buf.buf;\n//     }\n\n//     string oraclize_network_name;\n//     function oraclize_setNetworkName(string _network_name) internal {\n//         oraclize_network_name = _network_name;\n//     }\n\n//     function oraclize_getNetworkName() internal view returns (string) {\n//         return oraclize_network_name;\n//     }\n\n//     function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n//         require((_nbytes > 0) && (_nbytes <= 32));\n//         // Convert from seconds to ledger timer ticks\n//         _delay *= 10;\n//         bytes memory nbytes = new bytes(1);\n//         nbytes[0] = byte(_nbytes);\n//         bytes memory unonce = new bytes(32);\n//         bytes memory sessionKeyHash = new bytes(32);\n//         bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n//         assembly {\n//             mstore(unonce, 0x20)\n//             // the following variables can be relaxed\n//             // check relaxed random contract under ethereum-examples repo\n//             // for an idea on how to override and replace comit hash vars\n//             mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n//             mstore(sessionKeyHash, 0x20)\n//             mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n//         }\n//         bytes memory delay = new bytes(32);\n//         assembly {\n//             mstore(add(delay, 0x20), _delay)\n//         }\n\n//         bytes memory delay_bytes8 = new bytes(8);\n//         copyBytes(delay, 24, 8, delay_bytes8, 0);\n\n//         bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n//         bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n\n//         bytes memory delay_bytes8_left = new bytes(8);\n\n//         assembly {\n//             let x := mload(add(delay_bytes8, 0x20))\n//             mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n//             mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n\n//         }\n\n//         oraclize_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\n//         return queryId;\n//     }\n\n//     function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n//         oraclize_randomDS_args[queryId] = commitment;\n//     }\n\n//     mapping(bytes32=>bytes32) oraclize_randomDS_args;\n//     mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n\n//     function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n//         bool sigok;\n//         address signer;\n\n//         bytes32 sigr;\n//         bytes32 sigs;\n\n//         bytes memory sigr_ = new bytes(32);\n//         uint offset = 4+(uint(dersig[3]) - 0x20);\n//         sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n//         bytes memory sigs_ = new bytes(32);\n//         offset += 32 + 2;\n//         sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n\n//         assembly {\n//             sigr := mload(add(sigr_, 32))\n//             sigs := mload(add(sigs_, 32))\n//         }\n\n\n//         (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n//         if (address(keccak256(pubkey)) == signer) return true;\n//         else {\n//             (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n//             return (address(keccak256(pubkey)) == signer);\n//         }\n//     }\n\n//     function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n//         bool sigok;\n\n//         // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\n//         bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n//         copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n\n//         bytes memory appkey1_pubkey = new bytes(64);\n//         copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n\n//         bytes memory tosign2 = new bytes(1+65+32);\n//         tosign2[0] = byte(1); //role\n//         copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n//         bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n//         copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n//         sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n\n//         if (sigok == false) return false;\n\n\n//         // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\n//         bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n\n//         bytes memory tosign3 = new bytes(1+65);\n//         tosign3[0] = 0xFE;\n//         copyBytes(proof, 3, 65, tosign3, 1);\n\n//         bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n//         copyBytes(proof, 3+65, sig3.length, sig3, 0);\n\n//         sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n\n//         return sigok;\n//     }\n\n//     modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n//         // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n//         require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n\n//         bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n//         require(proofVerified);\n\n//         _;\n//     }\n\n//     function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n//         // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\n//         if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n\n//         bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n//         if (proofVerified == false) return 2;\n\n//         return 0;\n//     }\n\n//     function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n//         bool match_ = true;\n\n//         require(prefix.length == n_random_bytes);\n\n//         for (uint256 i=0; i< n_random_bytes; i++) {\n//             if (content[i] != prefix[i]) match_ = false;\n//         }\n\n//         return match_;\n//     }\n\n//     function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n\n//         // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\n//         uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n//         bytes memory keyhash = new bytes(32);\n//         copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n//         if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(context_name, queryId)))))) return false;\n\n//         bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n//         copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n\n//         // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\n//         if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n\n//         // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\n//         // This is to verify that the computed args match with the ones specified in the query.\n//         bytes memory commitmentSlice1 = new bytes(8+1+32);\n//         copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n\n//         bytes memory sessionPubkey = new bytes(64);\n//         uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n//         copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n\n//         bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n//         if (oraclize_randomDS_args[queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))){ //unonce, nbytes and sessionKeyHash match\n//             delete oraclize_randomDS_args[queryId];\n//         } else return false;\n\n\n//         // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\n//         bytes memory tosign1 = new bytes(32+8+1+32);\n//         copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n//         if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n\n//         // verify if sessionPubkeyHash was verified already, if not.. let's do it!\n//         if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n//             oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n//         }\n\n//         return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n//     }\n\n//     // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n//     function copyBytes(\n//         bytes memory from,\n//         uint fromOffset,\n//         uint length,\n//         bytes memory to,\n//         uint toOffset\n//         ) internal pure returns (bytes memory) {\n\n//         uint minLength = length + toOffset;\n\n//         // Buffer too small\n//         require(to.length >= minLength, 'buffer too small'); // Should be a better way?\n\n//         // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\n//         uint i = 32 + fromOffset;\n//         uint j = 32 + toOffset;\n\n//         while (i < (32 + fromOffset + length)) {\n//             assembly {\n//                 let tmp := mload(add(from, i))\n//                 mstore(add(to, j), tmp)\n//             }\n//             i += 32;\n//             j += 32;\n//         }\n\n//         return to;\n//     }\n\n//     // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n//     // Duplicate Solidity's ecrecover, but catching the CALL return value\n//     function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n//         // We do our own memory management here. Solidity uses memory offset\n//         // 0x40 to store the current end of memory. We write past it (as\n//         // writes are memory extensions), but don't update the offset so\n//         // Solidity will reuse it. The memory used here is only needed for\n//         // this context.\n\n//         // FIXME: inline assembly can't access return values\n//         bool ret;\n//         address addr;\n\n//         assembly {\n//             let size := mload(0x40)\n//             mstore(size, hash)\n//             mstore(add(size, 32), v)\n//             mstore(add(size, 64), r)\n//             mstore(add(size, 96), s)\n\n//             // NOTE: we can reuse the request memory because we deal with\n//             //       the return code\n//             ret := call(3000, 1, 0, size, 128, size, 32)\n//             addr := mload(size)\n//         }\n\n//         return (ret, addr);\n//     }\n\n//     // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\n//     function ecrecovery(bytes32 hash, bytes memory sig) internal returns (bool, address) {\n//         bytes32 r;\n//         bytes32 s;\n//         uint8 v;\n\n//         if (sig.length != 65)\n//           return (false, 0);\n\n//         // The signature format is a compact form of:\n//         //   {bytes32 r}{bytes32 s}{uint8 v}\n//         // Compact means, uint8 is not padded to 32 bytes.\n//         assembly {\n//             r := mload(add(sig, 32))\n//             s := mload(add(sig, 64))\n\n//             // Here we are loading the last 32 bytes. We exploit the fact that\n//             // 'mload' will pad with zeroes if we overread.\n//             // There is no 'mload8' to do this, but that would be nicer.\n//             v := byte(0, mload(add(sig, 96)))\n\n//             // Alternative solution:\n//             // 'byte' is not working due to the Solidity parser, so lets\n//             // use the second best option, 'and'\n//             // v := and(mload(add(sig, 65)), 255)\n//         }\n\n//         // albeit non-transactional signatures are not specified by the YP, one would expect it\n//         // to match the YP range of [27, 28]\n//         //\n//         // geth uses [0, 1] and some clients have followed. This might change, see:\n//         //  https://github.com/ethereum/go-ethereum/issues/2053\n//         if (v < 27)\n//           v += 27;\n\n//         if (v != 27 && v != 28)\n//             return (false, 0);\n\n//         return safer_ecrecover(hash, v, r, s);\n//     }\n\n//     function safeMemoryCleaner() internal pure {\n//         assembly {\n//             let fmem := mload(0x40)\n//             codecopy(fmem, codesize, sub(msize, fmem))\n//         }\n//     }\n\n}\n// // </ORACLIZE_API>",
  "sourcePath": "/Users/jaxcoder/Documents/Blockchain/InsureNET/applications/admin-tool/src/contracts/vendors/usingOraclize.sol",
  "ast": {
    "absolutePath": "/Users/jaxcoder/Documents/Blockchain/InsureNET/applications/admin-tool/src/contracts/vendors/usingOraclize.sol",
    "exportedSymbols": {
      "OraclizeI": [
        2464
      ]
    },
    "id": 2465,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 2463,
        "literals": [
          "solidity",
          "0.5",
          ".16"
        ],
        "nodeType": "PragmaDirective",
        "src": "1432:23:27"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 2464,
        "linearizedBaseContracts": [
          2464
        ],
        "name": "OraclizeI",
        "nodeType": "ContractDefinition",
        "nodes": [],
        "scope": 2465,
        "src": "1577:54967:27"
      }
    ],
    "src": "1432:55134:27"
  },
  "legacyAST": {
    "absolutePath": "/Users/jaxcoder/Documents/Blockchain/InsureNET/applications/admin-tool/src/contracts/vendors/usingOraclize.sol",
    "exportedSymbols": {
      "OraclizeI": [
        2464
      ]
    },
    "id": 2465,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 2463,
        "literals": [
          "solidity",
          "0.5",
          ".16"
        ],
        "nodeType": "PragmaDirective",
        "src": "1432:23:27"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 2464,
        "linearizedBaseContracts": [
          2464
        ],
        "name": "OraclizeI",
        "nodeType": "ContractDefinition",
        "nodes": [],
        "scope": 2465,
        "src": "1577:54967:27"
      }
    ],
    "src": "1432:55134:27"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.16+commit.9c3226ce.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.23",
  "updatedAt": "2020-04-01T00:37:25.493Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}