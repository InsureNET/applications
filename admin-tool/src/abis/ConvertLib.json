{
  "contractName": "ConvertLib",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.5.16+commit.9c3226ce\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/home/jaxcoder/Projects/InetMaster/applications/admin-tool/src/contracts/utility/convertLib.sol\":\"ConvertLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"/home/jaxcoder/Projects/InetMaster/applications/admin-tool/src/contracts/utility/convertLib.sol\":{\"keccak256\":\"0x0df5e5a1acb6e77481581c85f28dec960f44d5668ac385e6e89e32385e8f945c\",\"urls\":[\"bzz-raw://539eb38abf4c1bfcf95e8ab5d4d07ed631ee1df1ec131c19a77855212fd4aaba\",\"dweb:/ipfs/QmRDwVxj9gyZRvzWwmwn7GHPGEYrb4r7LePTRFBCXZauVa\"]}},\"version\":1}",
  "bytecode": "0x6080604052348015600f57600080fd5b50603e80601d6000396000f3fe6080604052600080fdfea265627a7a72315820526441fea101f5d2426130f3ca4b3e9da4a9a67c6a92608df087ceb4215eeadf64736f6c63430005100032",
  "deployedBytecode": "0x6080604052600080fdfea265627a7a72315820526441fea101f5d2426130f3ca4b3e9da4a9a67c6a92608df087ceb4215eeadf64736f6c63430005100032",
  "sourceMap": "182:3226:30:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;182:3226:30;;;;;;;",
  "deployedSourceMap": "182:3226:30:-;;;;;",
  "source": "// /**\n//  * Oraclized Underwriting and Payout\n//  *\n//  * @description\tConversions\n//  * @copyright (c) 2020 InsureNET\n//  * @author Jason Romero\n//  */\n\n\npragma solidity 0.5.16;\n\n\ncontract ConvertLib {\n\n//   // For date-time lib function getYear\n//   uint16 internal constant ORIGIN_YEAR = 1970;\n//   uint internal constant YEAR_IN_SECONDS = 31536000;\n//   uint internal constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n//   // .. since beginning of the year\n//   uint16[12] internal days_since = [\n//     11,\n//     42,\n//     70,\n//     101,\n//     131,\n//     162,\n//     192,\n//     223,\n//     254,\n//     284,\n//     315,\n//     345\n//   ];\n\n//   function b32toHexString(bytes32 x) internal pure returns (string memory) {\n//     bytes memory b = new bytes(64);\n//     for (uint i = 0; i < 32; i++) {\n//       uint8 by = uint8(uint(x) / (2**(8*(31 - i))));\n//       uint8 high = by/16;\n//       uint8 low = by - 16*high;\n//       if (high > 9) {\n//         high += 39;\n//       }\n//       if (low > 9) {\n//         low += 39;\n//       }\n//       b[2*i] = byte(high+48);\n//       b[2*i+1] = byte(low+48);\n//     }\n\n//     return string(b);\n//   }\n\n//   // helper functions for getYear\n//   function isLeapYear(uint16 year) internal pure returns (bool) {\n//     if (year % 4 != 0) {\n//       return false;\n//     }\n//     if (year % 100 != 0) {\n//       return true;\n//     }\n//     if (year % 400 != 0) {\n//       return false;\n//     }\n//     return true;\n//   }\n\n//   function leapYearsBefore(uint year) internal pure returns (uint) {\n//     year -= 1;\n//     return year / 4 - year / 100 + year / 400;\n//   }\n\n//   function getYear(uint timestamp) internal pure returns (uint16) {\n//     uint secondsAccountedFor = 0;\n//     uint16 year;\n//     uint numLeapYears;\n\n//     // Year\n//     year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n//     numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n\n//     secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n//     secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n\n//     while (secondsAccountedFor > timestamp) {\n//       if (isLeapYear(uint16(year - 1))) {\n//         secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n//       } else {\n//         secondsAccountedFor -= YEAR_IN_SECONDS;\n//       }\n//       year -= 1;\n//     }\n//     return year;\n//   }\n\n//   function stringToBytes32(string memory _source) internal pure returns (bytes32 result) {\n//     bytes memory tempEmptyStringTest = bytes(_source);\n//     if (tempEmptyStringTest.length == 0) {\n//       return 0x0;\n//     }\n\n//     /* solhint-disable no-inline-assembly */\n//     assembly {\n//       result := mload(add(_source, 32))\n//     }\n//     /* solhint-enable no-inline-assembly */\n//   }\n\n//   function b32toString(\n//     bytes32 x\n//     ) internal pure returns (string memory) {\n//     // gas usage: about 1K gas per char.\n//     bytes memory bytesString = new bytes(32);\n//     uint charCount = 0;\n\n//     for (uint j = 0; j < 32; j++) {\n//       byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n//       if (char != 0) {\n//         bytesString[charCount] = char;\n//         charCount++;\n//       }\n//     }\n\n//     bytes memory bytesStringTrimmed = new bytes(charCount);\n\n//     for (j = 0; j < charCount; j++) {\n//       bytesStringTrimmed[j] = bytesString[j];\n//     }\n\n//     return string(bytesStringTrimmed);\n//   }\n }",
  "sourcePath": "/home/jaxcoder/Projects/InetMaster/applications/admin-tool/src/contracts/utility/convertLib.sol",
  "ast": {
    "absolutePath": "/home/jaxcoder/Projects/InetMaster/applications/admin-tool/src/contracts/utility/convertLib.sol",
    "exportedSymbols": {
      "ConvertLib": [
        3999
      ]
    },
    "id": 4000,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 3998,
        "literals": [
          "solidity",
          "0.5",
          ".16"
        ],
        "nodeType": "PragmaDirective",
        "src": "156:23:30"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 3999,
        "linearizedBaseContracts": [
          3999
        ],
        "name": "ConvertLib",
        "nodeType": "ContractDefinition",
        "nodes": [],
        "scope": 4000,
        "src": "182:3226:30"
      }
    ],
    "src": "156:3252:30"
  },
  "legacyAST": {
    "absolutePath": "/home/jaxcoder/Projects/InetMaster/applications/admin-tool/src/contracts/utility/convertLib.sol",
    "exportedSymbols": {
      "ConvertLib": [
        3999
      ]
    },
    "id": 4000,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 3998,
        "literals": [
          "solidity",
          "0.5",
          ".16"
        ],
        "nodeType": "PragmaDirective",
        "src": "156:23:30"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 3999,
        "linearizedBaseContracts": [
          3999
        ],
        "name": "ConvertLib",
        "nodeType": "ContractDefinition",
        "nodes": [],
        "scope": 4000,
        "src": "182:3226:30"
      }
    ],
    "src": "156:3252:30"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.16+commit.9c3226ce.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.23",
<<<<<<< HEAD
  "updatedAt": "2020-04-18T18:34:25.000Z",
=======
  "updatedAt": "2020-04-16T14:28:55.025Z",
>>>>>>> 36b0d5f3bf0ebccba57c4d0791aae1d41cb5c827
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}